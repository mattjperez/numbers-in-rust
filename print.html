<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Numbers in Rust</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Learn the foundations of numbers as implemented in Rust">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="num_representation/intro.html"><strong aria-hidden="true">2.</strong> Number Representation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="num_representation/unsigned_integers.html"><strong aria-hidden="true">2.1.</strong> Unsigned Integers</a></li><li class="chapter-item expanded "><a href="num_representation/signed_integers.html"><strong aria-hidden="true">2.2.</strong> Signed Integers</a></li><li class="chapter-item expanded "><a href="num_representation/floats.html"><strong aria-hidden="true">2.3.</strong> Floats</a></li><li class="chapter-item expanded "><a href="num_representation/endianness.html"><strong aria-hidden="true">2.4.</strong> Endianness</a></li><li class="chapter-item expanded "><a href="isize-and-usize.html"><strong aria-hidden="true">2.5.</strong> isize and usize</a></li></ol></li><li class="chapter-item expanded "><a href="operators/intro.html"><strong aria-hidden="true">3.</strong> Operators</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="operators/add.html"><strong aria-hidden="true">3.1.</strong> Add (+)</a></li><li class="chapter-item expanded "><a href="operators/sub.html"><strong aria-hidden="true">3.2.</strong> Sub (-)</a></li><li class="chapter-item expanded "><a href="operators/mul.html"><strong aria-hidden="true">3.3.</strong> Mul (*)</a></li><li class="chapter-item expanded "><a href="operators/div.html"><strong aria-hidden="true">3.4.</strong> Div (/)</a></li><li class="chapter-item expanded "><a href="operators/rem.html"><strong aria-hidden="true">3.5.</strong> Rem (%)</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Conversion</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="conversion/from.html"><strong aria-hidden="true">4.1.</strong> From</a></li><li class="chapter-item expanded "><a href="conversion/as.html"><strong aria-hidden="true">4.2.</strong> As</a></li></ol></li><li class="chapter-item expanded "><a href="overflow/intro.html"><strong aria-hidden="true">5.</strong> Overflow</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="overflow/wrapping.html"><strong aria-hidden="true">5.1.</strong> Wrapping</a></li><li class="chapter-item expanded "><a href="overflow/saturating.html"><strong aria-hidden="true">5.2.</strong> Saturating</a></li><li class="chapter-item expanded "><a href="overflow/overflowing.html"><strong aria-hidden="true">5.3.</strong> Overflowing</a></li><li class="chapter-item expanded "><a href="overflow/checked.html"><strong aria-hidden="true">5.4.</strong> Checked</a></li><li class="chapter-item expanded "><a href="overflow/unchecked.html"><strong aria-hidden="true">5.5.</strong> Unchecked</a></li></ol></li><li class="chapter-item expanded "><a href="bitwise/intro.html"><strong aria-hidden="true">6.</strong> Bitwise Operations</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="bitwise/and.html"><strong aria-hidden="true">6.1.</strong> AND (&amp;)</a></li><li class="chapter-item expanded "><a href="bitwise/or.html"><strong aria-hidden="true">6.2.</strong> OR (|)</a></li><li class="chapter-item expanded "><a href="bitwise/xor.html"><strong aria-hidden="true">6.3.</strong> XOR (^)</a></li><li class="chapter-item expanded "><a href="bitwise/not.html"><strong aria-hidden="true">6.4.</strong> NOT (!)</a></li><li class="chapter-item expanded "><a href="bitwise/left-shift.html"><strong aria-hidden="true">6.5.</strong> L-Shift (&lt;&lt;)</a></li><li class="chapter-item expanded "><a href="bitwise/right-shift.html"><strong aria-hidden="true">6.6.</strong> R-Shift (&gt;&gt;)</a></li></ol></li><li class="chapter-item expanded "><a href="constants.html"><strong aria-hidden="true">7.</strong> Constants</a></li><li class="chapter-item expanded "><a href="crates.html"><strong aria-hidden="true">8.</strong> Popular Crates</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Numbers in Rust</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/mattjperez/numbers-in-rust/tree/main" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="intro"><a class="header" href="#intro">Intro</a></h1>
<p>Hey everyone, welcome to my Numbers in Rust!</p>
<p>This is a one-stop-shop for all things numbers as they relate to Rust and includes foundational CS information when we think it would be helpful.
It is a living document and will continue to grow until it lives up to its goal.
If you would like to help, please feel free to contribute via Issues, Pull-Requests, and Discussions on the repo!</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="number-representation"><a class="header" href="#number-representation">Number Representation</a></h1>
<p>In computer science, everything (at the moment) is represented by <code>1</code>'s and <code>0</code>'s, stored in groupings such as <code>bytes</code> (8 <code>bits</code>).<br />
Each bit represents a <strong>power of 2</strong>, so a group of <strong>8 bits</strong> representing the number <code>130</code> may look like this.</p>
<table><thead><tr><th align="center">Bits</th><th align="center">1</th><th align="center">0</th><th align="center">0</th><th align="center">0</th><th align="center">0</th><th align="center">0</th><th align="center">1</th><th align="center">0</th></tr></thead><tbody>
<tr><td align="center">Base 10 (Decimal)</td><td align="center">128</td><td align="center">64</td><td align="center">32</td><td align="center">16</td><td align="center">8</td><td align="center">4</td><td align="center">2</td><td align="center">1</td></tr>
<tr><td align="center">Base 2 (Binary)</td><td align="center">2<sup>7</sup></td><td align="center">2<sup>6</sup></td><td align="center">2<sup>5</sup></td><td align="center">2<sup>4</sup></td><td align="center">2<sup>3</sup></td><td align="center">2<sup>2</sup></td><td align="center">2<sup>1</sup></td><td align="center">2<sup>0</sup></td></tr>
</tbody></table>
<p><code>128 + 0 + 0 + 0 + 0 + 0 + 2 + 0 == 130</code>
The above representation is that of an <code>unsigned</code> integer with <code>8-bits</code>, i.e. Rust's <code>u8</code>.</p>
<blockquote>
<p>For simplicity, we'll only be looking at the <code>8-bit</code> variants of integers in this major section. You can apply these topics to the larger variants by extending the number of bits towards the left-hand side, i.e. 256, 512, etc.</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="unsigned-integers"><a class="header" href="#unsigned-integers">Unsigned Integers</a></h1>
<p>In computer science, everything (at the moment) is represented by <code>1</code>'s and <code>0</code>'s, stored in groupings such as <code>bytes</code> (8 <code>bits</code>).<br />
Each bit represents a <strong>power of 2</strong>, so a group of <strong>8 bits</strong> representing the number <code>130</code> may look like this.</p>
<table><thead><tr><th align="center">Bits</th><th align="center">1</th><th align="center">0</th><th align="center">0</th><th align="center">0</th><th align="center">0</th><th align="center">0</th><th align="center">1</th><th align="center">0</th></tr></thead><tbody>
<tr><td align="center">Base 10 (Decimal)</td><td align="center">128</td><td align="center">64</td><td align="center">32</td><td align="center">16</td><td align="center">8</td><td align="center">4</td><td align="center">2</td><td align="center">1</td></tr>
<tr><td align="center">Base 2 (Binary)</td><td align="center">2<sup>7</sup></td><td align="center">2<sup>6</sup></td><td align="center">2<sup>5</sup></td><td align="center">2<sup>4</sup></td><td align="center">2<sup>3</sup></td><td align="center">2<sup>2</sup></td><td align="center">2<sup>1</sup></td><td align="center">2<sup>0</sup></td></tr>
</tbody></table>
<p><code>128 + 0 + 0 + 0 + 0 + 0 + 2 + 0 == 130</code>
The above representation is that of an <code>unsigned</code> integer with <code>8-bits</code>, i.e. Rust's <code>u8</code>.</p>
<blockquote>
<p>For simplicity, we'll only be looking at the <code>8-bit</code> variants of integers in this major section. You can apply these topics to the larger variants by extending the number of bits towards the left-hand side, i.e. 256, 512, etc.</p>
</blockquote>
<p>Rust makes viewing these representations fairly straightforward using one of its convenient formatting </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;{:b}&quot;, 128);
// 10000000


println!(&quot;{:08b}&quot;, 1); // packed with 0's, up to 8 places
// 00000001
<span class="boring">}
</span></code></pre></pre>
<p>The largest number representable by <code>u8</code> (all bits set to <code>1</code>) is <code>255</code>, and the lowest number (all bits set to <code>0</code>) is <code>0</code>.  If we tried to represent something larger, say <code>256</code>, this would happen.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let num: u8 = 256;
println!(&quot;{}&quot;, num);

// 
 --&gt; src/main.rs:2:19
  |
2 |     let num: u8 = 256;
  |                   ^^^
  |
  = note: `#[deny(overflowing_literals)]` on by default
  = note: the literal `256` does not fit into the type `u8` whose range is `0..=255`
// rustc's error messages are really thoughtful, thanks compiler team!

<span class="boring">}
</span></code></pre></pre>
<p>The two notes above are especially helpful because they </p>
<p>a.  try to provide as much detail as possible to the context of the error, possibly helping you fix the issue immediately, and </p>
<p>b. give you keywords to search for more in-depth information (<code>overflowing_literals</code>). </p>
<p>These numbers are <code>unsigned</code> because they do not contain a <code>sign bit</code>, a bit used to indicate whether a number is positive or negative. 
Therefore <strong>unsigned integers can only represent positive values</strong>.
This makes them perfect for modeling situations where negative values don't exist, like a shopping cart; you can't have <code>-1 headphones</code> in your cart, right? 
As you'll see in the section on <code>signed integers</code>, the maximum number you can represent in a <code>u8</code> is larger than that of an <code>i8</code>.
This is true for <code>unsigned</code> type to their <code>signed</code> counterpart. </p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="signed-integers"><a class="header" href="#signed-integers">Signed Integers</a></h1>
<p>There are different ways to represent signed integers, Rust uses a method called <a href="https://en.wikipedia.org/wiki/Two%27s_complement">two's complement</a>. 
Ben Eater has a <a href="https://www.youtube.com/watch?v=4qH4unVtJkE&amp;t=29s">video on two's complement</a> where he does an amazing job of explaining things. The next few sub-sections are merely a recap of his video so feel free to skip it if you're familiar with the concept. I'm including this as a convenient reference when looking at how Rust handles integer overflow.</p>
<h4 id="unsigned-operations"><a class="header" href="#unsigned-operations">Unsigned Operations</a></h4>
<p>To add two <code>unsigned</code> integers, convert them to their binary representations and add them as you would with pen and paper, by carrying the bit to the next .</p>
<pre><code>128 = 10000000
+ 2 = 00000010
---------------
130 = 10000010
</code></pre>
<h4 id="introducing-a-sign-bit-signed-magnitude"><a class="header" href="#introducing-a-sign-bit-signed-magnitude">Introducing a Sign Bit, Signed Magnitude</a></h4>
<p>A simple way to represent positive and negative numbers is by adding a <code>sign bit</code>. In this case, <code>0</code> represents positive integers while <code>1</code> represents negative integers.</p>
<pre><code>64 with sign bit
0 1 0 0 0 0 0 0

-64 with sign bit
1 1 0 0 0 0 0 0
</code></pre>
<p>You'll notice we've lost an entire power of 2 by introducing a sign bit. The range we can represent with 8 bits has gone from <code>0..=255</code> to <code>-127..=127</code>.</p>
<p>While that's the cost to represent negatives, we've also lost the ability to add/subtract bits how we did previously, at least when negative numbers are involved.</p>
<pre><code>8 + (-8)
  0 0 0 0 1 0 0 0
+ 1 0 0 0 1 0 0 0
-----------------
  1 0 0 1 0 0 0 0  == -16 ???
</code></pre>
<h4 id="ones-complement"><a class="header" href="#ones-complement">One's Complement</a></h4>
<p>Sign bit and mirrored bits</p>
<pre><code>24 in 8-bit ones-complement
 +/-  64 32  16  8  4  2  1
  0   0   0   1  1  0  0  0

-24 in 8-bit ones-complement
 +/-  64  32  16  8  4  2  1
  1   1   1   0  0  1  1  1

</code></pre>
<p>Almost, but not quite there. The following scenarios still happen.</p>
<pre><code>There are two distinct possibilities for 0.
 +/-  64 32  16  8  4  2  1
  0   0   0   0  0  0  0  0  =  0
  1   0   0   0  0  0  0  0  = -0

!!!!!!!!Fix the next example

Operations with two negative numbers are off-by-one
(-8) + (-10)  
  1 1 1 1 0 1 1 1  // -8
+ 1 1 1 1 0 1 0 1  // -10
-----------------
  1 1 1 1 1 1 0 0  == -1


</code></pre>
<h4 id="twos-complement"><a class="header" href="#twos-complement">Two's Complement</a></h4>
<p>One's complement, but with <code>-0</code> removed, has the effect of converting the <em>largest bit</em> to a negative.</p>
<pre><code>24 as u8
 128  64 32  16  8  4  2  1
  0   0   0   1  1  0  0  0

24 as i8
-128  64  32  16  8  4  2  1
  0    0   0   1  1  0  0  0
  
Bit Addition/Subtraction is restored!
You also now know why the min and max values representable with twos-complement are off-by-one!
</code></pre>
<h4 id="flipping-signs-with-twos-complement"><a class="header" href="#flipping-signs-with-twos-complement">Flipping Signs with Two's Complement</a></h4>
<ol>
<li>Invert the bits</li>
<li>Add 1</li>
</ol>
<pre><code>24 as u8
 128  64 32  16  8  4  2  1
  0   0   0   1  1  0  0  0
  
1) Invert the bits
  1   1   1   0  0  1  1  1
2) Add 1 (carry bits forward)
  1   1   1   0  1  0  0  0
  
-24 as i8
-128  64  32  16  8  4  2  1
  1   1   1   0  1  0  0  0

-128 + 64 + 32 + 8 
-128 + 104
-24
  
</code></pre>
<p>There you have it, this is how signed integers are represented in Rust.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="floats"><a class="header" href="#floats">Floats</a></h1>
<p>Floats in Rust follow the 2008 revision of the IEEE-754 standard on 
<a href="https://en.wikipedia.org/wiki/Single-precision_floating-point_format">single-precision floating-points</a>(e.g. <code>f32</code>, <code>float</code>, <code>binary32</code>)
and <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">double-precision floating-points</a>(e.g. <code>f64</code>, <code>double</code>, <code>binary64</code>) representations of floating-points.</p>
<blockquote>
<p>Don't use floats for financial operations</p>
</blockquote>
<pre><code> 1/2, 1/4, 1/8, 1/16, 1/32
</code></pre>
<p>Better precision -&gt; smaller range</p>
<p>larger range -&gt; worse precision</p>
<p>Mantissa vs exponent</p>
<p>//TODO: Insert photos of float binary representations</p>
<p>23 binary digits of precision for f32</p>
<p>56 binary digits of precision for f64</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="endianness"><a class="header" href="#endianness">Endianness</a></h1>
<p>Won't go into too much detail here, but it wouldn't feel write to have something with this much about data representation and not mention endianness.
Endianness is basically the ordering of bytes. </p>
<p>In all the examples I've displayed, you'll notice the Most Significant Byte (MSB) is on the left-hand side
with the Least-Significant-Bit (LSB) on the right-hand side. If we were to expand this from <code>8-bit</code> to <code>16-bit</code> it would look like this</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//TODO: add rust-examples of how to see these representations
<span class="boring">}
</span></code></pre></pre>
<pre><code>
  |---------------------------------------------------------unsigned 32-bit integer------------------------------------------------- -|
S |-------------------------------2 bytes---------------------------|-------------------------------2 bytes---------------------------| E
T |---------------8-bits -----------------| -----------8-bits-------|---------------8-bits------------------| -----------8-bits-------|
A |-------nibble--------|------nibble-----|----nibble---|---nibble--|-------nibble--------|------nibble-----|----nibble---|---nibble--| N
R |32768 16384 8192 4096|2048 1024 512 256|128 64 32  16| 8  4  2  1| 32768 16384 8192 4096|2048 1024 512 256|128 64 32 16| 8  4  2  1|  
T |  1     0     1    0 |  1    0   1   0 | 1   0  1   1| 1  0  1  1|  1     1     0    0 |  1    1   0   0 | 1   1  0   1| 1  1  0  1| D
  |---------------------|-----------------|-------------|-----------|---------------------|-----------------|-------------|-----------| 
0x|           A         |         A       |       B           B     |           C         |        C        |     D       |    D      |
</code></pre>
<p>This is referred to as Big-Endian or Network Byte Order (as it's the ordering used for network traffic).</p>
<p>The opposite ordering is called Little-Endian, and looks like this.</p>
<pre><code>  |---------------------------------------------------------unsigned 32-bit integer------------------------------------------------- -|
S |-------------------------------2 bytes---------------------------|-------------------------------2 bytes---------------------------| E
T |---------------8-bits -----------------| -----------8-bits-------|---------------8-bits------------------| -----------8-bits-------|
A |-------nibble--------|------nibble-----|----nibble---|---nibble--|-------nibble--------|------nibble-----|----nibble---|---nibble--| N
R |32768 16384 8192 4096|2048 1024 512 256|128 64 32  16| 8  4  2  1| 32768 16384 8192 4096|2048 1024 512 256|128 64 32 16| 8  4  2  1|  
T |  1     1     0    1 |  1    1   0   1 | 1   1  0   0| 1  1  0  0|  1     0     1    1 |  1    0   1   1 | 1   0  1   0| 1  0  1  0| D
  |---------------------|-----------------|-------------|-----------|---------------------|-----------------|-------------|-----------| 
0x|          D          |        D        |      C      |    C      |           B         |         B       |       A     |     A     |
</code></pre>
<p>However, many of the most popular architectures and operating systems are Little-Endian, where the LSB would be on the left-hand side and MSB on the right-hand side. 
This means that little-endian architectures need to convert the byte ordering of network traffic in order to use it.</p>
<p>This is a bit of a black-hole of a subject so we won't go much further into it.
Just know that this is an annoying thing to be aware of if you're ever implementing things where byte ordering is a thing.</p>
<p>The Rust standard library has numerical methods to identify, enforce, and referse byte orderings.
Just look for methods with letters like <code>le</code> (little-endian), <code>be</code> (big-endian), and <code>ne</code> (native endian).</p>
<p><a href="https://jira.mongodb.org/browse/SERVER-1625">Example of endianness and compatibility</a>
<a href="https://dflund.se/%7Epi/mongo_big_endian.html">Endianness, alignment, and char signage incompatibility</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="isize-and-usize"><a class="header" href="#isize-and-usize"><code>isize</code> and <code>usize</code></a></h1>
<p>According to <a href="https://doc.rust-lang.org/reference/types/numeric.html#machine-dependent-integer-types">The Rust Reference</a>, these integer types are machine-dependent and use the same number of bits as that of a pointer in the machine. This makes <code>usize</code> and <code>isize</code> proportional to the size of the machine's address space, and this is determined by its architecture (x86-64, etc). These types can be 16-bit, 32-bit, or 64-bit depending on the machine. However, due to many pieces of Rust code assuming sizes of 32-bit or 64-bit (common pointer sizes in modern architectures), 16-bit support is limited.
The primary concerns around machine-dependent types are that of portability and security. 
By using <code>isize</code> or <code>usize</code> at inappropriate points in your code, you're introducing variation in how your code <em>could</em> operate. These could manifest as overflows on machines with 16-bit pointers due to the lack of support as mentioned at the beginning of this section or something less obvious (which is arguably worse). </p>
<p>So when should I use them? 
After some a few posts on the <a href="https://users.rust-lang.org">Rust User Forum</a>, reddit, and stackoverflow, 
their usage tends to gravitate around two things:</p>
<ul>
<li>indexing into an array</li>
<li>offsets</li>
</ul>
<p>Even when it comes to the above, <code>usize</code> appears to be the dominant type used in these cases, with few general use-cases for <code>isize</code>.</p>
<blockquote>
<p>If you have any opinions on this or any major use-cases you think would be useful for others, please feel free to open an issue/pull-request/discussion!</p>
</blockquote>
<p>You could argue that this narrow scope actually leads to further introspection when it comes to what you're writing.
It forces you to think more deeply about the bounds of the operations you'll be performing, and in doing so, make it easier to select the most appropriate type for the situation. 
From a holistic view, this makes your logic more robust and better aligned with the <em>spirit</em> of Rust.</p>
<p>Basically, stick to explicit integer types as much as possible and be wary when using machine-dependent integers outside of the narrow scope above.</p>
<p>Originally called <code>int/uint</code>, but was one of the early RFCs.
https://github.com/rust-lang/rfcs/blob/master/text/0544-rename-int-uint.md</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="operators"><a class="header" href="#operators">Operators</a></h1>
<p>Operators are made available to different types and structures via certain traits (<code>Add</code>, <code>Sub</code>, <code>Rem</code>, etc).
However, these traits (and therefore operators) have different implementations depending on the type.
These implementations may have general norms and exceptions depending on the type and the operation. 
This section will help you determine if you can use a regular operator for an operation or if you should use an overflow-specific method.</p>
<p>https://github.com/rust-lang/rfcs/pull/560</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="add-"><a class="header" href="#add-">Add (+)</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="sub--"><a class="header" href="#sub--">Sub (-)</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="mul-"><a class="header" href="#mul-">Mul (*)</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id=""><a class="header" href="#">/</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="rem-"><a class="header" href="#rem-">Rem (%)</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="converting-with-from"><a class="header" href="#converting-with-from">Converting with <code>From</code></a></h1>
<p>For numeric types, <code>From</code> is only implemented for <em>lossless</em> conversions. </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ten_as_i64 = i64::from(10_i32) // Ok!
let ten_as_i32 = i32::from(10_i64) // Panics!
<span class="boring">}
</span></code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="casting-with-as"><a class="header" href="#casting-with-as">Casting with As</a></h1>
<p><code>as</code> works for <strong>both</strong> <em>lossless</em> and <em>lossy</em> conversions.</p>
<p>When casting from one integer type to another integer type, with the same number of bits, it is a <a href="https://en.wikipedia.org/wiki/NOP_(code)">no-op</a>, as in nothing happens.
The underlying bits have not changed, merely the <em>lens</em> which these bytes are interpreted changes from that of a <code>u128</code> to an <code>i128</code>.
Unlike <code>From</code>, the true value of the integer is not maintained and the bits are merely interpreted as the destination type's encoding.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>println!(&quot;128_u8 `as` i8 becomes {}&quot;, 128_u8 as i8);
// 128_u8 `as` i8 becomes -128
<span class="boring">}
</span></code></pre></pre>
<p><a href="https://doc.rust-lang.org/1.49.0/reference/expressions/operator-expr.html#type-cast-expressions">Rust Reference on Type Casting</a></p>
<p><a href="https://doc.rust-lang.org/1.49.0/reference/expressions/operator-expr.html#semantics">Rust Reference on Casting Semantics</a></p>
<p>https://doc.rust-lang.org/stable/rust-by-example/types/cast.html</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="overflow"><a class="header" href="#overflow">Overflow</a></h1>
<p><a href="https://doc.rust-lang.org/1.49.0/reference/expressions/operator-expr.html#overflow">Rust Reference on Overflow</a></p>
<blockquote>
<p>Integer operators will panic when they overflow when compiled in debug mode. The -C debug-assertions and -C overflow-checks compiler flags can be used to control this more directly. The following things are considered to be overflow:</p>
<ul>
<li>When +, * or - create a value greater than the maximum value, or less than the minimum value that can be stored. This includes unary - on the smallest value of any signed integer type.</li>
<li>Using / or %, where the left-hand argument is the smallest integer of a signed integer type and the right-hand argument is -1.</li>
<li>Using &lt;&lt; or &gt;&gt; where the right-hand argument is greater than or equal to the number of bits in the type of the left-hand argument, or is negative.</li>
</ul>
</blockquote>
<blockquote>
<p>The following is a paraphrasing from <a href="http://huonw.github.io/blog/2016/04/myths-and-legends-about-integer-overflow-in-rust/">Myths and Legends about Integer Overflow in Rust</a></p>
</blockquote>
<p>Rust's standard library provides four additional methods to handle bit overflows.
These explicit implementations give you precise control over your numerical operations to ensure a defined behavior.</p>
<ul>
<li><code>wrapping_&lt;add/sub/mul/div/etc...&gt;</code></li>
<li><code>saturating_&lt;add/sub/mul/div/etc...&gt;</code></li>
<li><code>overflowing_&lt;add/sub/mul/div/etc...&gt;</code></li>
<li><code>checked_&lt;add/sub/mul/div/etc...&gt;</code></li>
<li><code>unchecked_&lt;add/sub/mul/div/etc...&gt;</code> // nightly-only (unchecked_math)</li>
</ul>
<p>These methods will prevent panicking when overflow occurs and let you overflow purposefully if that's your intention (like in hashing algorithms and ring buffers).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//TODO: Elaborate on these further, especially in regard to signed integers`
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>wrapping_..</code> returns the straight two's complement result</li>
<li><code>saturating_..</code> returns the largest/smallest value (as appropriate) of the type when overflow occurs</li>
<li><code>overflowing_..</code> returns the two's complement result along with a boolean indicating if overflow occured</li>
<li><code>checked_..</code> returns an <code>Option</code> that's <code>None</code> if overflowing occurs</li>
<li><code>unchecked_..</code> assumes overflow cannot occur. Results in undefined behavior when <code>result &gt; &lt;int&gt;::MAX || result &lt; &lt;int&gt;::MIN</code></li>
</ul>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//TODO: examples
<span class="boring">}
</span></code></pre></pre>
<h4 id="rust-vs-cc-on-overflows"><a class="header" href="#rust-vs-cc-on-overflows">Rust vs C/C++ on overflows</a></h4>
<p><a href="https://www.reddit.com/r/rust/comments/931leq/why_are_i32s_the_fastest/e3a3eop?utm_source=share&amp;utm_medium=web2x&amp;context=3">Reddit: Why are i32s the Fastest?</a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="wrapping"><a class="header" href="#wrapping">Wrapping</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="saturating"><a class="header" href="#saturating">Saturating</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="overflowing"><a class="header" href="#overflowing">Overflowing</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="checked"><a class="header" href="#checked">Checked</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="unchecked"><a class="header" href="#unchecked">Unchecked</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="bitwise-operations"><a class="header" href="#bitwise-operations">Bitwise Operations</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="and-"><a class="header" href="#and-">AND (&amp;)</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="or-"><a class="header" href="#or-">OR (|)</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="xor-"><a class="header" href="#xor-">XOR (^)</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="not-"><a class="header" href="#not-">NOT (!)</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="l-shift-"><a class="header" href="#l-shift-">L-Shift (&lt;&lt;)</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="r-shift-"><a class="header" href="#r-shift-">R-Shift (&gt;&gt;)</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="constants"><a class="header" href="#constants">Constants</a></h1>
<p>As great as it is to know what happens under the hood, it would be nice to have convenient ways to... </p>
<ul>
<li>check what is the difference in precision for Pi as an <code>f32</code> vs an <code>f64</code></li>
<li>see what the minimum or maximum value for a given type is, like <code>i128</code> or <code>u128</code>.</li>
<li>represent <code>infinity</code> or <code>negative infinity</code> or <code>NaN</code></li>
</ul>
<p>That's where constants come in. </p>
<blockquote>
<p>fun fact: in the source code, <code>NAN</code> is represented as <code>0.0_f32 / 0.0_f32</code>, <code>INFINITY</code> as <code>1.0_f32 / 0.0_f32</code>, and <code>NEG_INFINITY</code> as <code>-1.0_f32 / 0.0_f32</code>.
Dividing by zero appears to have its uses :) </p>
</blockquote>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>//TODO: Add examples
<span class="boring">}
</span></code></pre></pre>
<p>Check a given type's documentation to see what kind of constants they have available. 
For example, <a href="https://doc.rust-lang.org/std/i128/index.html"><code>std::i128</code></a> and <a href="https://doc.rust-lang.org/std/f32/consts/index.html"><code>std::f32</code></a></p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="popular-crates"><a class="header" href="#popular-crates">Popular Crates</a></h1>
<blockquote>
<p>Maintained Crates only</p>
</blockquote>
<h2 id="general"><a class="header" href="#general">General</a></h2>
<ul>
<li><a href="https://crates.io/crates/rand">rand</a>: Random number generators and other randomness functionality.</li>
<li><a href="https://lib.rs/crates/num-bigint">num-bigint</a>: Big integer implementation for Rust.</li>
<li><a href="">num-traits</a>: Numeric traits for generic mathematics</li>
<li><a href="">num-integer</a>: Integer traits and functions.</li>
<li><a href="">number-prefix</a>: Library for numeric prefixes (kilo, giga, kibi).</li>
</ul>
<h2 id="linear-algebra"><a class="header" href="#linear-algebra">Linear Algebra</a></h2>
<ul>
<li><a href="">nalgebra</a>: General-purpose linear algebra library</li>
<li><a href="">matrixmultiply</a>: General-purpose linear algebra library</li>
</ul>
<h2 id="statistics"><a class="header" href="#statistics">Statistics</a></h2>
<ul>
<li><a href="">statrs</a>: Statistical computing library for Rust.</li>
</ul>
<h2 id="geometry"><a class="header" href="#geometry">Geometry</a></h2>
<ul>
<li><a href="">euclid</a>: Geometry primitives</li>
</ul>
<h2 id="data-processing"><a class="header" href="#data-processing">Data Processing</a></h2>
<ul>
<li><a href="">polars</a>: DataFrame Library based on Apache Arrow</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        <script type="text/javascript">
            window.playground_line_numbers = true;
        </script>
        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
